// Generated by CoffeeScript 1.7.1
var api;

api = require('../api');

describe('Api', function() {
  it('should be ready in less than 5000ms', function(done) {
    this.timeout(5000);
    return api.getApplications(function(stringArray) {
      return done();
    });
  });
  return describe('method', function() {
    describe('getApplications', function() {
      it('should be a Function', function() {
        return api.getApplications.should.be.a.Function;
      });
      it('should return an array of strings ', function(done) {
        return api.getApplications(function(stringArray) {
          var supposedString, _i, _len;
          stringArray.should.be.an.Array.and.should.not.be.empty;
          for (_i = 0, _len = stringArray.length; _i < _len; _i++) {
            supposedString = stringArray[_i];
            supposedString.should.be.a.String;
          }
          return done();
        });
      });
      return it('should throw an exception on bad params ', function() {
        return api.getApplications.bind(null, null).should["throw"]();
      });
    });
    describe('getCorridors', function() {
      it('should be a Function', function() {
        return api.getCorridors.should.be.a.Function;
      });
      it('should return an array of strings ', function(done) {
        return api.getCorridors(function(stringArray) {
          var supposedString, _i, _len;
          stringArray.should.be.an.Array.and.should.not.be.empty;
          for (_i = 0, _len = stringArray.length; _i < _len; _i++) {
            supposedString = stringArray[_i];
            supposedString.should.be.a.String;
          }
          return done();
        });
      });
      return it('should throw an exception on bad params ', function() {
        return api.getCorridors.bind(null, null).should["throw"]();
      });
    });
    describe('getEvents', function() {
      it('should be a Function', function() {
        return api.getEvents.should.be.a.Function;
      });
      it('should return an array of Events ', function(done) {
        return api.getEvents(function(eventArray) {
          var index, supposedEvent, _i, _len;
          eventArray.should.be.an.Array.and.should.not.be.empty;
          for (index = _i = 0, _len = eventArray.length; _i < _len; index = ++_i) {
            supposedEvent = eventArray[index];
            if (index % 2 === 0) {
              supposedEvent.should.have.keys(['id', 'codeapp', 'couloir', 'codetype', 'start_time', 'seen', 'deleted', 'old_value', 'value', 'diff_stddev', 'type']);
            }
          }
          return done();
        });
      });
      return it('should throw an exception on bad params ', function() {
        var next;
        next = function(result) {
          return console.log(result);
        };
        return api.getEvents.bind(null, null).should["throw"]();
      });
    });
    describe('setEvent', function() {
      it('should be a Function', function() {
        return api.setEvent.should.be.a.Function;
      });
      it('should return true', function(done) {
        return api.getEvents(function(eventArray) {
          var event, next, random;
          random = Math.floor((Math.random() * eventArray.length + 1) / 1);
          event = eventArray[random];
          next = function(result) {
            result.should.be.ok;
            return done();
          };
          return api.setEvent(next, event);
        });
      });
      it('should return false on update fail', function(done) {
        return api.getEvents(function(eventArray) {
          var event, next, random;
          random = Math.floor((Math.random() * eventArray.length + 1) / 1);
          event = eventArray[random];
          event.id = -1;
          next = function(result) {
            console.log;
            result.should.not.be.ok;
            return done();
          };
          return api.setEvent(next, event);
        });
      });
      return it('should throw an exception on bad params', function() {
        return api.getEvents(function(eventArray) {
          var event, next, random;
          random = Math.floor((Math.random() * eventArray.length + 1) / 1);
          event = eventArray[random];
          event.id = -1;
          event.seen = 'banana';
          next = function(value) {
            return value;
          };
          return api.setEvent.bind(next, event).should["throw"]();
        });
      });
    });
    describe('getHistory', function() {
      it('should be a Function', function() {
        return api.getHistory.should.be.a.Function;
      });
      it('should return an array of Values', function(done) {
        var next, options;
        options = {
          app: 'all',
          corridor: 'all',
          limit: 1000
        };
        next = function(valuesArray) {
          valuesArray.should.be.an.Array;
          return done();
        };
        return api.getHistory(next, options);
      });
      it('should return an empty array on inexistant params', function(done) {
        var next, options;
        options = {
          app: 'yolo',
          corridor: 'swag',
          limit: 1000
        };
        next = function(valuesArray) {
          valuesArray.should.be.an.Array.and.be.empty;
          return done();
        };
        return api.getHistory(next, options);
      });
      it('should throw an exception on bad params', function() {
        var next;
        next = function(valuesArray) {
          console.log(valuesArray);
          return done();
        };
        return api.getHistory.bind(null, next).should["throw"]();
      });
      return it('should throw an exception on bad callback', function() {
        return api.getHistory.bind(null).should["throw"]();
      });
    });
    describe('getTrend', function() {
      it('should be a Function', function() {
        return api.getTrend.should.be.a.Function;
      });
      it('getTrend should return an empty object on bad params', function(done) {
        var next, options;
        options = {
          app: 'all',
          corridor: 'all'
        };
        next = function(values) {
          values.should.be.an.Object;
          return done();
        };
        return api.getTrend(next, options);
      });
      it('getTrend should return an Object containing Values', function(done) {
        var next, options;
        options = {
          app: 'VMIR',
          corridor: 'X_00'
        };
        next = function(values) {
          var item, key, value, _i, _len;
          values.should.be.an.Object.and.should.not.be.empty;
          for (key in values) {
            value = values[key];
            key.should.be.a.String;
            value.should.be.an.Array;
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              item = value[_i];
              item.should.be.an.Object;
              item.should.have.keys(['somme', 'average', 'stddev', 'starttime']);
              item.somme.should.be.a.Number.and.greaterThan(-1);
              item.average.should.be.a.Number.and.greaterThan(-1);
              item.stddev.should.be.a.Number.and.greaterThan(-1);
              item.starttime.should.be.Date;
            }
          }
          return done();
        };
        return api.getTrend(next, options);
      });
      it('should throw an exception on bad params', function() {
        return api.getTrend.bind(null, null).should["throw"]();
      });
      return it('should throw an exception on bad params values', function() {
        var options;
        options = {
          yolo: 'swag'
        };
        return api.getTrend.bind(null, null, options).should["throw"]();
      });
    });
    return describe('getOverviewData', function() {
      it('should be a Function', function() {
        return api.getOverviewData.should.be.a.Function;
      });
      it('should return an array', function() {
        return api.getOverviewData(function(data) {
          var item, _i, _len, _results;
          data.should.be.an.Array;
          _results = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            item.should.have.keys(['codeapp', 'couloir', 'codetype', 'start_time', 'value', 'sante', 'types']);
            item.codeapp.should.be.a.String;
            item.couloir.should.be.a.String;
            item.codetype.should.be.a.String;
            item.start_time.should.be.a.String;
            item.value.should.be.a.String;
            item.sante.should.be.a.String;
            _results.push(item.types.should.be.an.Object);
          }
          return _results;
        });
      });
      return it('should throw an exception on bad callback', function() {
        return api.getOverviewData.bind(null, null).should["throw"]();
      });
    });
  });
});


/*	

		it 'getHistory should return  an array of objects', ->
			api.should.have.property 'getHistory'
			api.getHistory.should.be.a.Function

		it 'getTrend should return  an array of objects', ->
			api.should.have.property 'getTrend'
			api.getTrend.should.be.a.Function

		it 'getCalls should return  a CallTree', ->
			api.should.have.property 'getCalls'
			api.getCalls.should.be.a.Function
 */
